[V0_FILE]typescriptreact:file="app/page.tsx" isMerged="true"
"use client"

import { useEffect, useMemo, useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import Link from "next/link"
import { cn } from "@/lib/utils"

type ApiResponse = {
  ok: boolean
  status: number
  data?: any
  error?: { code: string; message: string }
}

const DEFAULT_SECRET = "whsec_test_123"
const DEFAULT_CURRENCY = "INR"

function randomId(len = 24) {
  const chars = "abcdefghijklmnopqrstuvwxyz0123456789"
  let out = ""
  for (let i = 0; i < len; i++) out += chars[Math.floor(Math.random() * chars.length)]
  return out
}

function useIdempotencyKey() {
  const [key, setKey] = useState("")
  useEffect(() => {
    setKey(`idem_${randomId(16)}`)
  }, [])
  return [key, () => setKey(`idem_${randomId(16)}`)] as const
}

function CodeBlock({ code }: { code: string }) {
  return (
    <pre className="mt-2 w-full overflow-auto rounded-md bg-muted p-3 text-xs leading-6">
      <code>{code}</code>
    </pre>
  )
}

function ResponseViewer({ res }: { res?: ApiResponse }) {
  if (!res) return null
  return (
    <Card className="mt-4">
      <CardHeader>
        <CardTitle>Response</CardTitle>
        <CardDescription>{res.ok ? `HTTP ${res.status}` : `Error (HTTP ${res.status})`}</CardDescription>
      </CardHeader>
      <CardContent>
        <CodeBlock code={JSON.stringify(res.ok ? res.data : res.error, null, 2)} />
      </CardContent>
    </Card>
  )
}

function PaymentForm() {
  const [amount, setAmount] = useState<string>("1000") // minor units
  const [currency, setCurrency] = useState<string>(DEFAULT_CURRENCY)
  const [idemKey, regenKey] = useIdempotencyKey()
  const [simulate, setSimulate] = useState<"none" | "timeout" | "requires_action" | "duplicate">("none")
  const [resp, setResp] = useState<ApiResponse>()
  const [loading, setLoading] = useState(false)

  const payload = useMemo(
    () => ({
      amount: Number(amount || "0"),
      currency,
      simulate: simulate !== "none" ? simulate : undefined,
      metadata: { order_id: `ord_${randomId(8)}` },
    }),
    [amount, currency, simulate],
  )

  const curl = useMemo(() => {
    const body = JSON.stringify(payload).replace(/"/g, '\\"')
    return [
      "curl -X POST https://your-preview-url.vercel.app/api/mock/payments",
      `  -H "Content-Type: application/json"`,
      `  -H "Idempotency-Key: ${idemKey}"`,
      `  -d "${body}"`,
    ].join(" \\\n")
  }, [payload, idemKey])

  const nodeFetch = useMemo(() => {
    return `import fetch from "node-fetch";

const res = await fetch("/api/mock/payments", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Idempotency-Key": "${idemKey}",
  },
  body: JSON.stringify(${JSON.stringify(payload, null, 2)}),
});

const json = await res.json();
console.log(json);`
  }, [payload, idemKey])

  async function submit() {
    setLoading(true)
    setResp(undefined)
    try {
      const res = await fetch("/api/mock/payments", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Idempotency-Key": idemKey,
        },
        body: JSON.stringify(payload),
      })
      const json = await res.json()
      setResp({ ok: res.ok, status: res.status, data: res.ok ? json : undefined, error: res.ok ? undefined : json })
    } catch (e: any) {
      setResp({
        ok: false,
        status: 0,
        error: { code: "network_error", message: e?.message || "Network error" },
      })
    } finally {
      setLoading(false)
    }
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="text-pretty">Create Payment (Mock)</CardTitle>
        <CardDescription>Validated request builder with idempotency and failure simulation</CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="grid gap-4 md:grid-cols-2">
          <div className="space-y-2">
            <Label htmlFor="amount">Amount (minor units)</Label>
            <Input
              id="amount"
              type="number"
              min={1}
              value={amount}
              onChange={(e) => setAmount(e.target.value)}
              placeholder="e.g. 1000 for ₹10.00"
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="currency">Currency</Label>
            <Input id="currency" value={currency} onChange={(e) => setCurrency(e.target.value.toUpperCase())} />
          </div>
          <div className="space-y-2 md:col-span-2">
            <Label htmlFor="idempotency">Idempotency-Key</Label>
            <div className="flex items-center gap-2">
              <Input id="idempotency" value={idemKey} readOnly />
              <Button type="button" variant="secondary" onClick={regenKey}>
                Regenerate
              </Button>
            </div>
          </div>
          <div className="space-y-2 md:col-span-2">
            <Label htmlFor="simulate">Simulate</Label>
            <div className="flex flex-wrap gap-2">
              {(["none", "requires_action", "timeout", "duplicate"] as const).map((opt) => (
                <Button
                  key={opt}
                  type="button"
                  variant={simulate === opt ? "default" : "outline"}
                  onClick={() => setSimulate(opt)}
                >
                  {opt}
                </Button>
              ))}
            </div>
          </div>
        </div>

        <div className="flex gap-3">
          <Button disabled={loading} onClick={submit}>
            {loading ? "Creating…" : "Create Payment"}
          </Button>
          <Link href="/dashboard" className={cn("text-sm underline self-center")}>
            View Dashboard
          </Link>
        </div>

        <Tabs defaultValue="curl" className="mt-4">
          <TabsList>
            <TabsTrigger value="curl">cURL</TabsTrigger>
            <TabsTrigger value="node">Node</TabsTrigger>
          </TabsList>
          <TabsContent value="curl">
            <CodeBlock code={curl} />
          </TabsContent>
          <TabsContent value="node">
            <CodeBlock code={nodeFetch} />
          </TabsContent>
        </Tabs>

        <ResponseViewer res={resp} />
      </CardContent>
    </Card>
  )
}

function WebhookLab() {
  const [url, setUrl] = useState<string>("")
  const [event, setEvent] = useState<string>("payment.succeeded")
  const [result, setResult] = useState<ApiResponse>()
  const [loading, setLoading] = useState(false)

  const verifySnippet = `import crypto from "crypto"

export function verify(body, signatureHeader, secret = "${DEFAULT_SECRET}") {
  const [tPart, v1Part] = signatureHeader.split(",")
  const t = tPart.split("=")[1]
  const provided = v1Part.split("=")[1]
  const payload = \`\${t}.\${JSON.stringify(body)}\`
  const hmac = crypto.createHmac("sha256", secret).update(payload).digest("hex")
  return crypto.timingSafeEqual(Buffer.from(hmac), Buffer.from(provided))
}`

  async function trigger() {
    setLoading(true)
    setResult(undefined)
    try {
      const res = await fetch("/api/mock/webhooks/trigger", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ url, eventType: event }),
      })
      const json = await res.json()
      setResult({ ok: res.ok, status: res.status, data: res.ok ? json : undefined, error: res.ok ? undefined : json })
    } catch (e: any) {
      setResult({ ok: false, status: 0, error: { code: "network_error", message: e?.message || "Network error" } })
    } finally {
      setLoading(false)
    }
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="text-pretty">Webhook Lab</CardTitle>
        <CardDescription>Send signed test events to your local/public URL</CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="space-y-2">
          <Label>Webhook URL</Label>
          <Input
            placeholder="https://example.com/webhooks/pine-labs"
            value={url}
            onChange={(e) => setUrl(e.target.value)}
          />
          <p className="text-xs text-muted-foreground">
            Tip: Use a tunnel like Cloudflare Tunnel/Ngrok when testing locally.
          </p>
        </div>
        <div className="flex flex-wrap gap-2">
          {["payment.succeeded", "payment.failed", "payment.requires_action"].map((name) => (
            <Button
              key={name}
              type="button"
              variant={event === name ? "default" : "outline"}
              onClick={() => setEvent(name)}
            >
              {name}
            </Button>
          ))}
        </div>
        <div className="flex gap-3">
          <Button disabled={!url || loading} onClick={trigger}>
            {loading ? "Sending…" : "Send Test Webhook"}
          </Button>
          <div className="self-center text-sm text-muted-foreground">
            Secret: <span className="font-mono">{DEFAULT_SECRET}</span> • Header:{" "}
            <span className="font-mono">X-PL-Signature</span>
          </div>
        </div>

        <div>
          <Label>Node signature verification</Label>
          <CodeBlock code={verifySnippet} />
        </div>

        <ResponseViewer res={result} />
      </CardContent>
    </Card>
  )
}

export default function Page() {
  return (
    <main className="mx-auto max-w-6xl p-4 md:p-8">
      <header className="mb-6">
        <h1 className="text-balance text-2xl font-semibold md:text-3xl">Pine Labs Quickstart Studio (Mock)</h1>
        <p className="text-muted-foreground">
          Self-explanatory, fast, resilient playground to integrate Pine Labs Online payment APIs without portal access.
        </p>
      </header>

      <div className="grid gap-6 md:grid-cols-2">
        <PaymentForm />
        <WebhookLab />
      </div>

      <section className="mt-8">
        <Card>
          <CardHeader>
            <CardTitle>What’s included</CardTitle>
            <CardDescription>Mock API, signed webhooks, idempotency, dashboard and CLI</CardDescription>
          </CardHeader>
          <CardContent className="text-sm text-muted-foreground">
            - POST /api/mock/payments (idempotent) • GET /api/mock/payments/:id • Webhook trigger with HMAC-SHA256
            signature
            <br />- Dashboard:{" "}
            <Link className="underline" href="/dashboard">
              /dashboard
            </Link>{" "}
            • CLI skeleton under /scripts/plol.mjs
          </CardContent>
        </Card>
      </section>
    </main>
  )
}
[V0_FILE]typescript:file="lib/store.ts" isEdit="true"
type Payment = {
  id: string
  amount: number
  currency: string
  status: "succeeded" | "failed" | "requires_action"
  created_at: string
  metadata: any
}

type Store = {
  payments: Map<string, Payment>
  idem: Map<string, string> // idemKey -> paymentId
  stats: { total: number; idempotencyChecks: number }
  webhookStats: { lastDeliveryAt?: string; lastStatus?: "ok" | "failed" }
}

let singleton: Store | null = null

export function getStore(): Store {
  if (singleton) return singleton
  singleton = {
    payments: new Map(),
    idem: new Map(),
    stats: { total: 0, idempotencyChecks: 0 },
    webhookStats: {},
  }
  return singleton
}
[V0_FILE]typescript:file="lib/signing.ts" isEdit="true"
import crypto from "crypto"

const DEFAULT_SECRET = "whsec_test_123"

export function signPayload(body: any, timestamp: string, secret = DEFAULT_SECRET) {
  const payload = `${timestamp}.${JSON.stringify(body)}`
  return crypto.createHmac("sha256", secret).update(payload).digest("hex")
}
[V0_FILE]typescript:file="app/api/mock/oauth/token/route.ts"
import { type NextRequest, NextResponse } from "next/server"

// Simple OAuth mock that issues a bearer token for client_credentials.
export async function POST(req: NextRequest) {
  const body = await req.json().catch(() => ({}))
  const { client_id, client_secret, grant_type } = body || {}

  if (grant_type !== "client_credentials") {
    return NextResponse.json(
      { error: "unsupported_grant_type", error_description: "Only client_credentials is supported in mock." },
      { status: 400 },
    )
  }

  // In mock mode, accept any client_id/secret; optionally demonstrate the sample pair.
  // You provided:
  // client_id: 844d40f0-81cf-4e87-9b89-9f1f35b8692e
  // client_secret: f420d050236741499ca5a529055b72e8
  const access_token = `pl_test_${Buffer.from((client_id || "anon") + Date.now())
    .toString("base64")
    .slice(0, 24)}`
  return NextResponse.json({
    access_token,
    token_type: "Bearer",
    expires_in: 3600,
    scope: "payments:write payments:read webhooks:send",
  })
}
[V0_FILE]typescript:file="app/api/mock/payments/route.ts" isEdit="true"
import { type NextRequest, NextResponse } from "next/server"
import { getStore } from "@/lib/store"

export async function POST(req: NextRequest) {
  const idem = req.headers.get("idempotency-key") || ""
  if (!idem) {
    return NextResponse.json(
      { code: "missing_idempotency", message: "Idempotency-Key header is required" },
      { status: 400 },
    )
  }

  const body = await req.json().catch(() => ({}))
  const { amount, currency, simulate, metadata } = body || {}

  if (typeof amount !== "number" || amount <= 0) {
    return NextResponse.json({ code: "invalid_amount", message: "amount (minor units) must be > 0" }, { status: 400 })
  }
  if (typeof currency !== "string" || currency.length !== 3) {
    return NextResponse.json({ code: "invalid_currency", message: "currency must be a 3-letter code" }, { status: 400 })
  }

  const store = getStore()
  // Idempotency handling
  const existingId = store.idem.get(idem)
  if (existingId) {
    const existing = store.payments.get(existingId)
    return NextResponse.json(existing, { status: 200 })
  }

  // Failure injection
  if (simulate === "timeout") {
    await new Promise((r) => setTimeout(r, 3000))
  }
  if (simulate === "duplicate") {
    return NextResponse.json({ code: "duplicate_request", message: "Duplicate payment detected" }, { status: 409 })
  }

  const id = `pay_${Math.random().toString(36).slice(2)}`
  const requiresAction = simulate === "requires_action"
  const now = new Date().toISOString()
  const payment = {
    id,
    amount,
    currency: currency.toUpperCase(),
    status: requiresAction ? "requires_action" : "succeeded",
    created_at: now,
    metadata: metadata || null,
  }

  store.payments.set(id, payment)
  store.idem.set(idem, id)
  store.stats.total += 1
  store.stats.idempotencyChecks += 1

  return NextResponse.json(payment, { status: requiresAction ? 202 : 201 })
}

export async function GET() {
  const store = getStore()
  const data = Array.from(store.payments.values()).sort((a: any, b: any) => (a.created_at < b.created_at ? 1 : -1))
  const idempotencyCoverage = store.stats.total ? Math.min(1, store.stats.idempotencyChecks / store.stats.total) : 0
  return NextResponse.json({
    data,
    stats: { total: store.stats.total, idempotencyChecks: store.stats.idempotencyChecks, idempotencyCoverage },
    webhookStats: store.webhookStats,
  })
}
[V0_FILE]typescript:file="app/api/mock/payments/[id]/route.ts" isEdit="true"
import { type NextRequest, NextResponse } from "next/server"
import { getStore } from "@/lib/store"

export async function GET(_req: NextRequest, { params }: { params: { id: string } }) {
  const store = getStore()
  const p = store.payments.get(params.id)
  if (!p) return NextResponse.json({ code: "not_found", message: "Payment not found" }, { status: 404 })
  return NextResponse.json(p)
}
[V0_FILE]typescript:file="app/api/mock/webhooks/trigger/route.ts" isEdit="true"
import { type NextRequest, NextResponse } from "next/server"
import { signPayload } from "@/lib/signing"
import { getStore } from "@/lib/store"

export async function POST(req: NextRequest) {
  const { url, eventType = "payment.succeeded", paymentId } = await req.json().catch(() => ({}))
  if (!url || typeof url !== "string") {
    return NextResponse.json({ code: "invalid_url", message: "Provide a valid URL" }, { status: 400 })
  }

  const store = getStore()
  const base = {
    id: `evt_${Math.random().toString(36).slice(2)}`,
    type: eventType,
    created_at: new Date().toISOString(),
  }

  const payment = (paymentId && store.payments.get(paymentId)) || {
    id: `pay_${Math.random().toString(36).slice(2)}`,
    amount: 1000,
    currency: "INR",
    status:
      eventType === "payment.failed"
        ? "failed"
        : eventType === "payment.requires_action"
          ? "requires_action"
          : "succeeded",
    created_at: new Date().toISOString(),
    metadata: null,
  }

  const body = { ...base, data: { object: payment } }
  const timestamp = Math.floor(Date.now() / 1000).toString()
  const signature = signPayload(body, timestamp) // hex
  const header = `t=${timestamp},v1=${signature}`

  let delivered = false
  let error: any = null
  try {
    const res = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json", "X-PL-Signature": header },
      body: JSON.stringify(body),
    })
    delivered = res.ok
    if (!res.ok) error = { status: res.status, statusText: res.statusText }
  } catch (e: any) {
    error = { message: e?.message || "Network error" }
  }

  store.webhookStats.lastDeliveryAt = new Date().toISOString()
  store.webhookStats.lastStatus = delivered ? "ok" : "failed"

  if (!delivered) return NextResponse.json({ delivered, error }, { status: 502 })
  return NextResponse.json({ delivered, event: body })
}
[V0_FILE]typescript:file="app/api/mock/metrics/route.ts"
import { NextResponse } from "next/server"
import { store } from "@/lib/store"

export async function GET() {
  const payments = store.listPayments(500)
  const counts = payments.reduce(
    (acc, p) => {
      acc[p.status]++
      return acc
    },
    { requires_action: 0, authorized: 0, captured: 0, failed: 0 } as Record<string, number>,
  )

  return NextResponse.json({
    totals: {
      payments: payments.length,
      ...counts,
      deliveries: store.listDeliveries(1000).length,
    },
    recentDeliveries: store.listDeliveries(10),
  })
}
[V0_FILE]typescriptreact:file="app/playground/page.tsx" isEdit="true"
"use client"

import { useEffect, useMemo, useState } from "react"
import Link from "next/link"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { cn } from "@/lib/utils"

type ApiResponse = {
  ok: boolean
  status: number
  data?: any
  error?: { code: string; message: string }
}

const DEFAULT_SECRET = "whsec_test_123"
const DEFAULT_CURRENCY = "INR"

function randomId(len = 24) {
  const chars = "abcdefghijklmnopqrstuvwxyz0123456789"
  let out = ""
  for (let i = 0; i < len; i++) out += chars[Math.floor(Math.random() * chars.length)]
  return out
}

function useIdempotencyKey() {
  const [key, setKey] = useState("")
  useEffect(() => {
    setKey(`idem_${randomId(16)}`)
  }, [])
  return [key, () => setKey(`idem_${randomId(16)}`)] as const
}

function CodeBlock({ code }: { code: string }) {
  return (
    <pre className="mt-2 w-full overflow-auto rounded-md bg-muted p-3 text-xs leading-6">
      <code>{code}</code>
    </pre>
  )
}

function ResponseViewer({ res }: { res?: ApiResponse }) {
  if (!res) return null
  return (
    <Card className="mt-4">
      <CardHeader>
        <CardTitle>Response</CardTitle>
        <CardDescription>{res.ok ? `HTTP ${res.status}` : `Error (HTTP ${res.status})`}</CardDescription>
      </CardHeader>
      <CardContent>
        <CodeBlock code={JSON.stringify(res.ok ? res.data : res.error, null, 2)} />
      </CardContent>
    </Card>
  )
}

function PaymentForm() {
  const [amount, setAmount] = useState<string>("1000") // minor units
  const [currency, setCurrency] = useState<string>(DEFAULT_CURRENCY)
  const [idemKey, regenKey] = useIdempotencyKey()
  const [simulate, setSimulate] = useState<"none" | "timeout" | "requires_action" | "duplicate">("none")
  const [resp, setResp] = useState<ApiResponse>()
  const [loading, setLoading] = useState(false)

  const payload = useMemo(
    () => ({
      amount: Number(amount || "0"),
      currency,
      simulate: simulate !== "none" ? simulate : undefined,
      metadata: { order_id: `ord_${randomId(8)}` },
    }),
    [amount, currency, simulate],
  )

  const curl = useMemo(() => {
    const body = JSON.stringify(payload).replace(/"/g, '\\"')
    return [
      "curl -X POST https://YOUR-LIVE-DOMAIN/api/mock/payments",
      `  -H "Content-Type: application/json"`,
      `  -H "Idempotency-Key: ${idemKey}"`,
      `  -d "${body}"`,
    ].join(" \\\n")
  }, [payload, idemKey])

  const nodeFetch = useMemo(() => {
    return `const res = await fetch("/api/mock/payments", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Idempotency-Key": "${idemKey}",
  },
  body: JSON.stringify(${JSON.stringify(payload, null, 2)}),
});
const json = await res.json();
console.log(json);`
  }, [payload, idemKey])

  async function submit() {
    setLoading(true)
    setResp(undefined)
    try {
      const res = await fetch("/api/mock/payments", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Idempotency-Key": idemKey,
        },
        body: JSON.stringify(payload),
      })
      const json = await res.json()
      setResp({ ok: res.ok, status: res.status, data: res.ok ? json : undefined, error: res.ok ? undefined : json })
    } catch (e: any) {
      setResp({
        ok: false,
        status: 0,
        error: { code: "network_error", message: e?.message || "Network error" },
      })
    } finally {
      setLoading(false)
    }
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="text-pretty">Create Payment (Mock)</CardTitle>
        <CardDescription>Validated request builder with idempotency and failure simulation</CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="grid gap-4 md:grid-cols-2">
          <div className="space-y-2">
            <Label htmlFor="amount">Amount (minor units)</Label>
            <Input
              id="amount"
              type="number"
              min={1}
              value={amount}
              onChange={(e) => setAmount(e.target.value)}
              placeholder="e.g. 1000 for ₹10.00"
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="currency">Currency</Label>
            <Input id="currency" value={currency} onChange={(e) => setCurrency(e.target.value.toUpperCase())} />
          </div>
          <div className="space-y-2 md:col-span-2">
            <Label htmlFor="idempotency">Idempotency-Key</Label>
            <div className="flex items-center gap-2">
              <Input id="idempotency" value={idemKey} readOnly />
              <Button type="button" variant="secondary" onClick={regenKey}>
                Regenerate
              </Button>
            </div>
          </div>
          <div className="space-y-2 md:col-span-2">
            <Label htmlFor="simulate">Simulate</Label>
            <div className="flex flex-wrap gap-2">
              {(["none", "requires_action", "timeout", "duplicate"] as const).map((opt) => (
                <Button
                  key={opt}
                  type="button"
                  variant={simulate === opt ? "default" : "outline"}
                  onClick={() => setSimulate(opt)}
                >
                  {opt}
                </Button>
              ))}
            </div>
          </div>
        </div>

        <div className="flex gap-3">
          <Button disabled={loading} onClick={submit}>
            {loading ? "Creating…" : "Create Payment"}
          </Button>
          <Link href="/dashboard" className={cn("text-sm underline self-center")}>
            View Dashboard
          </Link>
        </div>

        <Tabs defaultValue="curl" className="mt-4">
          <TabsList>
            <TabsTrigger value="curl">cURL</TabsTrigger>
            <TabsTrigger value="node">Node</TabsTrigger>
          </TabsList>
          <TabsContent value="curl">
            <CodeBlock code={curl} />
          </TabsContent>
          <TabsContent value="node">
            <CodeBlock code={nodeFetch} />
          </TabsContent>
        </Tabs>

        <ResponseViewer res={resp} />
      </CardContent>
    </Card>
  )
}

function WebhookLab() {
  const [url, setUrl] = useState<string>("")
  const [event, setEvent] = useState<string>("payment.succeeded")
  const [result, setResult] = useState<ApiResponse>()
  const [loading, setLoading] = useState(false)

  const verifySnippet = `import crypto from "crypto"

export function verify(body, signatureHeader, secret = "${DEFAULT_SECRET}") {
  const [tPart, v1Part] = signatureHeader.split(",")
  const t = tPart.split("=")[1]
  const provided = v1Part.split("=")[1]
  const payload = \`\${t}.\${JSON.stringify(body)}\`
  const hmac = crypto.createHmac("sha256", secret).update(payload).digest("hex")
  return crypto.timingSafeEqual(Buffer.from(hmac), Buffer.from(provided))
}`

  async function trigger() {
    setLoading(true)
    setResult(undefined)
    try {
      const res = await fetch("/api/mock/webhooks/trigger", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ url, eventType: event }),
      })
      const json = await res.json()
      setResult({ ok: res.ok, status: res.status, data: res.ok ? json : undefined, error: res.ok ? undefined : json })
    } catch (e: any) {
      setResult({ ok: false, status: 0, error: { code: "network_error", message: e?.message || "Network error" } })
    } finally {
      setLoading(false)
    }
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="text-pretty">Webhook Lab</CardTitle>
        <CardDescription>Send signed test events to your local/public URL</CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="space-y-2">
          <Label>Webhook URL</Label>
          <Input
            placeholder="https://example.com/webhooks/pine-labs"
            value={url}
            onChange={(e) => setUrl(e.target.value)}
          />
          <p className="text-xs text-muted-foreground">
            Tip: Use a tunnel like Cloudflare Tunnel/Ngrok when testing locally.
          </p>
        </div>
        <div className="flex flex-wrap gap-2">
          {["payment.succeeded", "payment.failed", "payment.requires_action"].map((name) => (
            <Button
              key={name}
              type="button"
              variant={event === name ? "default" : "outline"}
              onClick={() => setEvent(name)}
            >
              {name}
            </Button>
          ))}
        </div>
        <div className="flex gap-3">
          <Button disabled={!url || loading} onClick={trigger}>
            {loading ? "Sending…" : "Send Test Webhook"}
          </Button>
          <div className="self-center text-sm text-muted-foreground">
            Secret: <span className="font-mono">{DEFAULT_SECRET}</span> • Header:{" "}
            <span className="font-mono">X-PL-Signature</span>
          </div>
        </div>

        <div>
          <Label>Node signature verification</Label>
          <CodeBlock code={verifySnippet} />
        </div>

        <ResponseViewer res={result} />
      </CardContent>
    </Card>
  )
}

export default function PlaygroundPage() {
  return (
    <main className="mx-auto max-w-6xl p-4 md:p-8">
      <header className="mb-6">
        <h1 className="text-balance text-2xl font-semibold md:text-3xl">Pine Labs Quickstart Playground (Mock)</h1>
        <p className="text-muted-foreground">
          Create a mock payment with idempotency, trigger signed webhooks, and track readiness—no portal required.
        </p>
      </header>

      <div className="grid gap-6 md:grid-cols-2">
        <PaymentForm />
        <WebhookLab />
      </div>

      <section className="mt-8">
        <Card>
          <CardHeader>
            <CardTitle>What’s included</CardTitle>
            <CardDescription>Mock API, signed webhooks, idempotency, dashboard and CLI</CardDescription>
          </CardHeader>
          <CardContent className="text-sm text-muted-foreground">
            - POST /api/mock/payments (idempotent) • GET /api/mock/payments/:id • Webhook trigger with HMAC-SHA256
            signature
            <br />- Dashboard:{" "}
            <Link className="underline" href="/dashboard">
              /dashboard
            </Link>{" "}
            • CLI skeleton under /scripts/plol.mjs
          </CardContent>
        </Card>
      </section>
    </main>
  )
}
[V0_FILE]typescriptreact:file="app/dashboard/page.tsx" isEdit="true"
"use client"

import useSWR from "swr"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"

const fetcher = (url: string) => fetch(url).then((r) => r.json())

export default function DashboardPage() {
  const { data } = useSWR("/api/mock/payments", fetcher, { refreshInterval: 5000 })
  const list = data?.data || []
  const count = list.length
  const succ = list.filter((p: any) => p.status === "succeeded").length
  const hasWebhook = data?.webhookStats?.lastDeliveryAt ? 1 : 0
  const hasIdem = data?.stats?.idempotencyCoverage || 0
  const readiness = Math.min(100, Math.round((succ > 0 ? 50 : 0) + hasWebhook * 25 + hasIdem * 25))

  return (
    <main className="mx-auto max-w-5xl p-4 md:p-8">
      <header className="mb-6">
        <h1 className="text-2xl font-semibold">Integration Health Dashboard</h1>
        <p className="text-muted-foreground">Track mock runs, webhooks, and go-live readiness</p>
      </header>

      <div className="grid gap-6 md:grid-cols-3">
        <Card>
          <CardHeader>
            <CardTitle>Total Mock Payments</CardTitle>
            <CardDescription>All runs in this preview session</CardDescription>
          </CardHeader>
          <CardContent className="text-3xl font-semibold">{count}</CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Succeeded</CardTitle>
            <CardDescription>Successful transactions</CardDescription>
          </CardHeader>
          <CardContent className="text-3xl font-semibold">{succ}</CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Readiness Score</CardTitle>
            <CardDescription>Higher = closer to go-live</CardDescription>
          </CardHeader>
          <CardContent className="text-3xl font-semibold">{readiness}%</CardContent>
        </Card>
      </div>

      <section className="mt-8">
        <Card>
          <CardHeader>
            <CardTitle>Recent Runs</CardTitle>
            <CardDescription>Latest mock payments</CardDescription>
          </CardHeader>
        </Card>
        <pre className="max-h-96 overflow-auto rounded bg-muted p-3 text-xs mt-4">
          {JSON.stringify(data || {}, null, 2)}
        </pre>
      </section>
    </main>
  )
}
[V0_FILE]javascript:file="scripts/plol.mjs" isEdit="true"
// Usage:
//   node scripts/plol.mjs new nextjs
//   node scripts/plol.mjs test --base http://localhost:3000
//   node scripts/plol.mjs doctor --base https://your-live-domain

import { argv, exit } from 'node:process'

function help() {
  console.log(`plol - Pine Labs Online CLI (mock)
Usage:
  plol new <stack>               Scaffold a starter (prints next steps)
  plol test [--base <url>]       Create a mock payment and print result
  plol doctor [--base <url>]     Run preflight checks (idempotency, health)
`)
}

function flag(name, def) {
  const i = argv.indexOf(name)
  if (i >= 0 && i + 1 < argv.length) return argv[i + 1]
  return def
}

async function run() {
  const cmd = argv[2]
  if (!cmd || ['-h', '--help'].includes(cmd)) return help()

  const base = flag('--base', 'http://localhost:3000')

  if (cmd === 'new') {
    const stack = argv[3] || 'nextjs'
    console.log(`Scaffolding ${stack} starter...
- Create a payment route that POSTs to ${base}/api/mock/payments
- Include Idempotency-Key header
- Add webhook route to receive signed events (X-PL-Signature; secret whsec_test_123)
- Run: node scripts/plol.mjs test --base ${base}
`)
    return
  }

  if (cmd === 'test') {
    try {
      const idem = 'idem_' + Math.random().toString(36).slice(2)
      const res = await fetch(`${base}/api/mock/payments`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Idempotency-Key': idem },
        body: JSON.stringify({ amount: 1000, currency: 'INR', metadata: { order_id: 'ord_cli' } }),
      })
      const json = await res.json()
      console.log('HTTP', res.status)
      console.log(JSON.stringify(json, null, 2))
      exit(res.ok ? 0 : 1)
    } catch (e) {
      console.error('Request failed:', e?.message || e)
      exit(1)
    }
  }

  if (cmd === 'doctor') {
    let ok = true
    try {
      const idem = 'idem_' + Math.random().toString(36).slice(2)
      const res = await fetch(`${base}/api/mock/payments`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Idempotency-Key': idem },
        body: JSON.stringify({ amount: 1000, currency: 'INR' }),
      })
      if (!res.ok) ok = false
      // Idempotency replay
      const replay = await fetch(`${base}/api/mock/payments`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Idempotency-Key': idem },
        body: JSON.stringify({ amount: 1000, currency: 'INR' }),
      })
      if (!replay.ok) ok = false
      console.log('Connectivity:', res.ok ? 'ok' : 'fail')
      console.log('Idempotency replay:', replay.ok ? 'ok' : 'fail')
    } catch (e) {
      ok = false
      console.error('Connectivity failed:', e?.message || e)
    }
    exit(ok ? 0 : 1)
  }

  help()
}

run()
[V0_FILE]markdown:file="README.md" isEdit="true"
# Pine Labs Quickstart Studio (Mock)

A self-explanatory, fast, and resilient playground to integrate Pine Labs Online payment flows without accessing the developer portal.

Quick start
- Publish from v0 to Vercel. Your live Playground will be at: https://YOUR-LIVE-DOMAIN/playground
- Create a payment (idempotent) and view stats at https://YOUR-LIVE-DOMAIN/dashboard
- Trigger signed webhooks to your endpoint using the Webhook Lab in the playground

Included
- Mock API:
  - POST /api/mock/payments (idempotent create; simulate: requires_action | timeout | duplicate)
  - GET /api/mock/payments/:id
  - GET /api/mock/payments (list + stats)
- Webhook Lab:
  - POST /api/mock/webhooks/trigger sends signed events to your URL
  - Header: X-PL-Signature  value: t=<ts>,v1=<hex>
  - Secret: whsec_test_123 (sample)
- Playground UI: /playground
- Dashboard: /dashboard
- CLI: /scripts/plol.mjs (`new`, `test`, `doctor`)

Go live later
- Keep the same code paths; swap base URLs and real keys when you gain production access.
